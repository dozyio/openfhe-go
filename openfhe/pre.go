package openfhe

/*
#cgo CPPFLAGS: -I${SRCDIR}/../openfhe-install/include -I${SRCDIR}/../openfhe-install/include/openfhe -I${SRCDIR}/../openfhe-install/include/openfhe/core -I${SRCDIR}/../openfhe-install/include/openfhe/pke -I${SRCDIR}/../openfhe-install/include/openfhe/binfhe -I${SRCDIR}/../openfhe-install/include/openfhe/cereal
#cgo CXXFLAGS: -std=c++17
#include <stdint.h>
#include "pre_c.h"
#include "pke_common_c.h"
*/
import "C"

import (
	"errors"
	"unsafe"
)

// EvalKey represents a re-encryption key used in Proxy Re-Encryption (PRE).
// It allows transforming ciphertexts encrypted under one key to be encrypted
// under another key without decryption.
type EvalKey struct {
	ptr C.EvalKeyPtr
}

// Close frees the underlying C++ EvalKey object.
func (ek *EvalKey) Close() {
	if ek.ptr != nil {
		C.DestroyEvalKey(ek.ptr)
		ek.ptr = nil
	}
}

// ReKeyGen generates a re-encryption key from oldPrivateKey to newPublicKey.
// This key allows transforming ciphertexts encrypted under the old public key
// to ciphertexts encrypted under the new public key without decryption.
//
// The PRE feature must be enabled on the CryptoContext before calling this function:
//
//	cc.Enable(openfhe.PRE)
//
// Parameters:
//   - oldKeys: KeyPair containing the old private key
//   - newKeys: KeyPair containing the new public key
//
// Returns:
//   - *EvalKey: The re-encryption key
//   - error: An error if the operation fails
//
// Example:
//
//	// Alice's keys
//	aliceKeys, _ := cc.KeyGen()
//	// Bob's keys
//	bobKeys, _ := cc.KeyGen()
//	// Generate re-encryption key from Alice to Bob
//	reencryptionKey, _ := cc.ReKeyGen(aliceKeys, bobKeys)
//	defer reencryptionKey.Close()
func (cc *CryptoContext) ReKeyGen(oldKeys, newKeys *KeyPair) (*EvalKey, error) {
	if cc.ptr == nil {
		return nil, errors.New("CryptoContext is closed or invalid")
	}
	if oldKeys == nil || oldKeys.ptr == nil {
		return nil, errors.New("oldKeys KeyPair is closed or invalid")
	}
	if newKeys == nil || newKeys.ptr == nil {
		return nil, errors.New("newKeys KeyPair is closed or invalid")
	}

	// Get the private key from oldKeys
	var oldSK unsafe.Pointer
	status := C.GetPrivateKey(oldKeys.ptr, &oldSK)
	err := checkPKEErrorMsg(status)
	if err != nil {
		return nil, err
	}
	if oldSK == nil {
		return nil, errors.New("oldKeys has no private key")
	}

	// Get the public key from newKeys
	var newPK unsafe.Pointer
	status = C.GetPublicKey(newKeys.ptr, &newPK)
	err = checkPKEErrorMsg(status)
	if err != nil {
		return nil, err
	}
	if newPK == nil {
		return nil, errors.New("newKeys has no public key")
	}

	var ekH C.EvalKeyPtr
	status = C.CryptoContext_ReKeyGen(cc.ptr, oldSK, newPK, &ekH)
	err = checkPKEErrorMsg(status)
	if err != nil {
		return nil, err
	}

	if ekH == nil {
		return nil, errors.New("ReKeyGen returned OK but null handle")
	}

	ek := &EvalKey{ptr: ekH}
	return ek, nil
}

// ReEncrypt transforms a ciphertext encrypted under one key to be encrypted
// under another key using the re-encryption key from ReKeyGen.
//
// The PRE feature must be enabled on the CryptoContext before calling this function:
//
//	cc.Enable(openfhe.PRE)
//
// Parameters:
//   - ct: The ciphertext to re-encrypt
//   - evalKey: The re-encryption key generated by ReKeyGen
//
// Returns:
//   - *Ciphertext: The re-encrypted ciphertext
//   - error: An error if the operation fails
//
// Example:
//
//	// Encrypt data with Alice's key
//	ct, _ := cc.Encrypt(aliceKeys, plaintext)
//	// Re-encrypt to Bob's key
//	reencryptedCt, _ := cc.ReEncrypt(ct, reencryptionKey)
//	// Now Bob can decrypt with his private key
//	result, _ := cc.Decrypt(bobKeys, reencryptedCt)
func (cc *CryptoContext) ReEncrypt(ct *Ciphertext, evalKey *EvalKey) (*Ciphertext, error) {
	if cc.ptr == nil {
		return nil, errors.New("CryptoContext is closed or invalid")
	}
	if ct == nil || ct.ptr == nil {
		return nil, errors.New("Ciphertext is closed or invalid")
	}
	if evalKey == nil || evalKey.ptr == nil {
		return nil, errors.New("EvalKey is closed or invalid")
	}

	var ctH C.CiphertextPtr
	status := C.CryptoContext_ReEncrypt(cc.ptr, ct.ptr, evalKey.ptr, &ctH)
	err := checkPKEErrorMsg(status)
	if err != nil {
		return nil, err
	}

	if ctH == nil {
		return nil, errors.New("ReEncrypt returned OK but null handle")
	}

	reencryptedCt := &Ciphertext{ptr: ctH}
	return reencryptedCt, nil
}
